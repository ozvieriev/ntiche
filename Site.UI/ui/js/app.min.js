"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

angular.module('app.components', ['ui.router', 'pascalprecht.translate']);
angular.module('app.auth', []);
angular.module('app.services', []);
angular.module('app.controllers', []);
angular.module('app.directives', []);
angular.module('app.filters', []);
angular.module('app', ['app.components', 'app.auth', 'app.services', 'app.controllers', 'app.directives', 'app.filters']).run(function ($transitions, $translate, $auth) {
  if (location.hash.toLowerCase().startsWith('#!/fr/')) $translate.use('fr'); //$trace.enable('TRANSITION');

  $transitions.onBefore({
    to: '**'
  }, function (transition) {
    var to = transition.to();
    if (!to.roles || $auth.isInRoles(to.roles)) return;
    var stateService = transition.router.stateService;
    var locale = stateService.params.locale || 'en';
    var params = {
      returnUrl: to.url.replace(/^\//g, ''),
      locale: locale
    };
    return transition.router.stateService.target('account/sign-in', params);
  }); //$transitions.onSuccess({ to: '**' }, (transition) => {
  //    let stateService = transition.router.stateService;
  //    let locale = stateService.params.locale;
  //    let currentLanguage = $translate.use();
  //    if (!currentLanguage || currentLanguage !== locale) {
  //        $translate.use(locale).then(() => {
  //            var d = $translate.use();
  //            $translate.refresh(d);
  //        });
  //    }
  //});
});
angular.module('app').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push(['$q', '$state', function ($q, $state) {
    var interceptor = {};

    interceptor.request = function (config) {
      var params = $state.params;

      if ($state.params && $state.params.locale) {
        config.headers['Accept-Language'] = $state.params.locale;
        if (config.params) config.params.languageIso2 = $state.params.locale;
      }

      return config;
    };

    interceptor.response = function (response) {
      var config = response.config || {};
      if (config.asJson === true) return response.data;
      return response;
    };

    interceptor.responseError = function (response) {
      if (response.config.asJson === true) {
        response.data = response.data || {};
        if (!response.data.error_description && !response.status === 401) $state.go('error');
        response.data.error_description = response.data.error_description || 'Sorry, the server is busy. Please try again later.';
      }

      return $q.reject(response);
    };

    return interceptor;
  }]);
}]);
angular.module('app').config(['$translateProvider', function ($translateProvider) {
  // // $translateProvider.useLoader('$i18nLoader', {});
  // // $translateProvider.useLocalStorage();
  //$translateProvider.useLoader('$translatePartialLoader', {
  //    urlTemplate: 'i18n/{lang}-{part}.json'
  //});
  //$translateProvider.preferredLanguage('en');
  //$translateProvider.fallbackLanguage('en');
  //$translatePartialLoaderProvider.addPart('index');
  $translateProvider.registerAvailableLanguageKeys(['en', 'fr'], {
    'en': 'en',
    'fr': 'fr'
  });
  $translateProvider.useStaticFilesLoader({
    prefix: 'i18n/',
    suffix: '.json'
  }); //$translateProvider.preferredLanguage('en');
  //$translateProvider.use('en');
  ////$translateProvider.useCookieStorage();
  //$translateProvider.fallbackLanguage("en");
}]);
angular.module('app').config(function ($stateProvider, $urlRouterProvider) {
  // $locationProvider.html5Mode({
  //     enabled: true,
  //     requireBase: false
  // });
  $urlRouterProvider.otherwise('/en/index');
  $stateProvider.state('app', {
    url: '/:locale',
    //templateUrl: 'index.html',
    restricted: false,
    abstract: true,
    views: {
      header: {
        templateUrl: 'partial/header.html',
        controller: 'partialHeaderController'
      },
      main: {
        controller: 'appController'
      },
      footer: {
        templateUrl: 'partial/footer.html'
      }
    }
  });

  var _state = function _state(json) {
    json.name = json.name || json.url;
    json.htmlUrl = json.htmlUrl || json.url;
    json.params = json.params || {};
    json.templateUrl = json.templateUrl || "views/".concat(json.htmlUrl, ".html");
    json.isProtected = !!json.isProtected;
    var state = {
      parent: 'app',
      url: "/".concat(json.url),
      params: json.params,
      templateUrl: json.templateUrl,
      isProtected: json.isProtected
    };
    if (json.controller) state.controller = "".concat(json.controller, "Controller");
    $stateProvider.state(json.name, state);
  };

  _state({
    url: 'account',
    htmlUrl: 'account/index',
    controller: 'account',
    roles: []
  });

  _state({
    url: 'account/email-confirmation/:accountId/:emailConfirmationToken',
    htmlUrl: 'account/email-confirmation',
    controller: 'accountEmailConfirmation'
  });

  _state({
    url: 'account/recover-password',
    controller: 'accountRecoverPassword'
  });

  _state({
    url: 'account/reset-password/:accountId/:resetPasswordToken',
    htmlUrl: 'account/reset-password',
    controller: 'accountResetPassword'
  });

  _state({
    url: 'account/sign-in',
    controller: 'accountSignIn',
    params: {
      returnUrl: null
    }
  });

  _state({
    url: 'account/sign-up',
    controller: 'accountSignUp'
  });

  _state({
    url: 'admin/report',
    controller: 'adminReport',
    roles: ['admin']
  });

  _state({
    url: 'exam/feedback',
    controller: 'examFeedback',
    roles: []
  });

  _state({
    url: 'exam/post-test',
    controller: 'examPostTest',
    roles: []
  });

  _state({
    url: 'exam/pre-test',
    controller: 'examPreTest',
    roles: []
  });

  _state({
    url: 'about'
  });

  _state({
    url: 'contact-us'
  });

  _state({
    url: 'disclaimer'
  });

  _state({
    url: 'error'
  });

  _state({
    url: 'index',
    controller: 'index'
  });

  _state({
    url: 'privacy'
  });

  _state({
    url: 'resources'
  });
}); //https://github.com/modularcode/modular-admin-angularjs/blob/master/src/_main.js

angular.module('app.auth').factory('$auth', ['$q', '$injector', '$authStorage', '$state', function ($q, $injector, $authStorage, $state) {
  var _apiHeaders = {
    'Content-Type': 'application/x-www-form-urlencoded'
  };

  var _uri = function _uri(method) {
    return "/".concat(method);
  };

  var service = {};

  service.isAuthenticated = function () {
    return !!service.identity();
  };

  service.identity = function () {
    return $authStorage.getItem();
  };

  service.accessToken = function () {
    var identity = service.identity();
    return identity ? identity.access_token : null;
  };

  service.isInRoles = function (roles) {
    var identity = service.identity();
    if (!identity) return false;
    if (!roles || !roles.length) return;
    var identityRoles = (identity.roles || '').toLowerCase().split(',');

    for (var index = 0; index < roles.length; index++) {
      var role = roles[index];
      if (identityRoles.indexOf(role) !== -1) return true;
    }

    return false;
  };

  service.signUp = function (data) {
    var $http = $injector.get("$http");
    data.countryIso2 = 'CA';
    return $http.post(_uri('api/account/register'), data, {
      asJson: true
    });
  };

  service.signIn = function (email, password, emailConfirmationToken, accountId) {
    var data = {
      grant_type: 'password'
    };
    email && (data.userName = email);
    password && (data.password = password);
    emailConfirmationToken && (data.emailConfirmationToken = emailConfirmationToken);
    accountId && (data.accountId = accountId);
    var deferred = $q.defer();
    var $http = $injector.get("$http");
    $http.post(_uri('api/token'), $.param(data), {
      headers: _apiHeaders,
      asJson: true
    }).then(function (json) {
      $authStorage.setItem(json);
      deferred.resolve(json);
    }, function (error) {
      deferred.reject(error);
    });
    return deferred.promise;
  };

  service.refreshToken = function () {
    var deferred = $q.defer();
    var identity = service.identity();

    if (identity) {
      var data = {
        grant_type: 'refresh_token',
        refresh_token: identity.refresh_token
      };
      var $http = $injector.get("$http");
      $http.post(_uri('api/token'), $.param(data), {
        headers: _apiHeaders,
        asJson: true
      }).then(function (json) {
        $authStorage.setItem(json);
        deferred.resolve(json);
      }, function (error) {
        debugger;
        deferred.reject();
      });
    } else deferred.reject();

    return deferred.promise;
  };

  service.logout = function () {
    $authStorage.removeItem();
    $state.go('account/sign-in');
  };

  service.emailConfirmation = function (emailConfirmationToken, accountId) {
    return service.signIn(null, null, emailConfirmationToken, accountId);
  };

  service.recoverPassword = function (params) {
    var $http = $injector.get("$http");
    return $http.get(_uri('api/account/recover-password'), {
      params: params,
      asJson: true
    });
  };

  service.resetPassword = function (resetPasswordToken, accountId, password) {
    var $http = $injector.get("$http");
    return $http.post(_uri('api/account/reset-password'), {
      resetPasswordToken: resetPasswordToken,
      accountId: accountId,
      password: password
    }, {
      asJson: true
    });
  };

  return service;
}]);
angular.module('app.auth').factory('$authBuffer', ['$injector', function ($injector) {
  /** Holds all the requests, so they can be re-requested in future. */
  var _buffer = [];
  /** Service initialized later because of circular dependency problem. */

  var $http;

  var _retryHttpRequest = function _retryHttpRequest(config, deferred) {
    var _success = function _success(response) {
      deferred.resolve(response);
    };

    var _error = function _error(response) {
      deferred.reject(response);
    };

    $http = $http || $injector.get('$http');
    $http(config).then(_success, _error);
  };

  var service = {};
  /**
  * Appends HTTP request configuration object with deferred response attached to buffer.
  */

  service.append = function (config, deferred) {
    _buffer.push({
      config: config,
      deferred: deferred
    });
  };
  /**
  * Abandon or reject (if reason provided) all the buffered requests.
  */


  service.rejectAll = function (reason) {
    if (reason) {
      for (var index = 0; index < _buffer.length; ++index) {
        _buffer[index].deferred.reject(reason);
      }
    }

    _buffer = [];
  };
  /**
   * Retries all the buffered requests clears the buffer.
   */


  service.retryAll = function (updater) {
    for (var index = 0; index < _buffer.length; ++index) {
      _retryHttpRequest(updater(_buffer[index].config), _buffer[index].deferred);
    }

    _buffer = [];
  };

  return service;
}]);
angular.module('app.auth').config(['$httpProvider', function ($httpProvider) {
  $httpProvider.interceptors.push(['$q', '$auth', '$authInterceptor', '$authBuffer', function ($q, $auth, $authInterceptor, $authBuffer) {
    var interceptor = {};

    interceptor.request = function (config) {
      config.headers = config.headers || {};
      var accessToken = $auth.accessToken();
      accessToken && (config.headers.Authorization = "bearer ".concat(accessToken));
      return config;
    };

    interceptor.responseError = function (rejection) {
      var config = rejection.config || {};

      switch (rejection.status) {
        case 401:
          var deferred = $q.defer();
          $authBuffer.append(config, deferred);
          $auth.refreshToken().then($authInterceptor.loginConfirmed, $auth.logout);
          return deferred.promise;
      }

      return $q.reject(rejection);
    };

    return interceptor;
  }]);
}]);
angular.module('app.auth').factory('$authInterceptor', ['$authBuffer', function ($authBuffer) {
  var service = {};
  /**
  * Call this function to indicate that authentication was successfull and trigger a
  * retry of all deferred requests.
  * @param data an optional argument to pass on to $broadcast which may be useful for
  * example if you need to pass through details of the user that was logged in
  * @param configUpdater an optional transformation function that can modify the
  * requests that are retried after having logged in.  This can be used for example
  * to add an authentication token.  It must return the request.
  */

  service.loginConfirmed = function (data, configUpdater) {
    var updater = configUpdater || function (config) {
      return config;
    };

    $authBuffer.retryAll(updater);
  };
  /**
   * Call this function to indicate that authentication should not proceed.
   * All deferred requests will be abandoned or rejected (if reason is provided).
   * @param data an optional argument to pass on to $broadcast.
   * @param reason if provided, the requests are rejected; abandoned otherwise.
   */


  service.loginCancelled = function (data, reason) {
    $authBuffer.rejectAll(reason);
  };

  return service;
}]);
angular.module('app.auth').factory('$authStorage', ['$window', function ($window) {
  var _localStorage = {};

  var _getItem = function _getItem(key) {
    var json = _localStorage[key];
    var value = json ? JSON.parse(json) : null;
    _localStorage[key] = json;

    try {
      json = $window.localStorage.getItem(key);
      json && (value = JSON.parse(json));
    } catch (error) {
      console.error(error);
    }

    return value;
  };

  var _setItem = function _setItem(key, value) {
    var json = JSON.stringify(value);
    _localStorage[key] = json;

    try {
      $window.localStorage.setItem(key, json);
    } catch (error) {
      console.error(error);
    }
  };

  var _removeItem = function _removeItem(key) {
    delete _localStorage[key];

    try {
      $window.localStorage.removeItem(key);
    } catch (error) {
      console.error(error);
    }
  };

  var service = {};

  service.getItem = function () {
    return _getItem('auth');
  };

  service.setItem = function (json) {
    _setItem('auth', json);
  };

  service.removeItem = function () {
    _removeItem('auth');
  };

  return service;
}]);
angular.module('app.controllers').controller('appController', ['$scope', '$state', '$stateParams', function ($scope, $state, $stateParams) {}]);
angular.module('app.controllers').controller('indexController', ['$scope', function ($scope) {}]);
angular.module('app.directives').directive('ngBraille', ['$window', function ($window) {
  var template = ['<ul class="navbar-nav braille mb-2">', '<li class="nav-item active" data-rem="1.0"><a class="nav-link">A</a></li>', '<li class="nav-item" data-rem="1.2"><a class="nav-link">A</a></li>', '<li class="nav-item" data-rem="1.5"><a class="nav-link">A</a></li>', '</ul>'].join('');
  return {
    restrict: 'E',
    replace: true,
    template: template,
    link: function link(scope, element, attrs) {
      var liCollection = element.find('li[data-rem]');
      liCollection.each(function (index, value) {
        var li = angular.element(value);
        var rem = li.attr('data-rem');
        li.css({
          'font-size': "".concat(rem, "rem"),
          'line-height': '1.7rem',
          cursor: 'pointer'
        });
        li.find('a').bind('click', function () {
          liCollection.removeClass('active');
          liCollection.eq(index).addClass('active');
          angular.element('body').css({
            'font-size': "".concat(rem, "rem")
          });
        });
      }); // element.find('a').bind('click', function () {
      //     var index = $(this).index();
      //     debugger
      //     $('body').css({ 'font-size': '1.2rem' });
      // });
    }
  };
}]);
angular.module('app.directives').directive('ngDate', ['$filter', function ($filter) {
  return {
    restrict: 'A',
    scope: {
      date: '=ngDate',
      format: '=ngFormat'
    },
    link: function link(scope, element, attrs) {
      if (!scope.date) return;
      element.addClass('text-muted small');
      var format = scope.format || 'yyyy-MM-dd HH:mm';
      scope.$watch('date', function (newValue, oldValue) {
        if (newValue || newValue != oldValue) element.html("<em>" + $filter('date')(scope.date, format) + "</em>");
      });
    }
  };
}]);
angular.module('app.directives').directive('ngLoadingForm', ['$window', function ($window) {
  return {
    restrict: 'A',
    scope: {},
    link: function link(scope, element, attrs) {
      var $submit = element.find('[type="submit"]');
      $submit.addClass('btn btn-primary');
      var watcher = scope.$watch('$parent.isBusy', function (isBusy) {
        isBusy ? $submit.addClass('btn-light') : $submit.removeClass('btn-light');
      });
      scope.$on('$destroy', watcher);
    }
  };
}]);
angular.module('app.directives').directive('ngNavbar', ['$window', function ($window) {
  return {
    restrict: 'A',
    link: function link(scope, element, attrs) {
      element.find('a').on('click', function () {
        angular.element('.navbar-collapse').collapse('hide');
      });
    }
  };
}]);
angular.module('app.services').factory('$api', ['$http', '$state', function factory($http, $state) {
  var _uri = function _uri(method) {
    return "/".concat(method);
  };

  var service = {};

  service.exam = function (name) {
    return $http.get(_uri('api/exam'), {
      params: {
        name: name || 'drugs'
      },
      asJson: true
    });
  };

  service.examResults = function () {
    return $http.get(_uri('api/exam/results'), {
      asJson: true
    });
  };

  service.examPost = function (name, answers) {
    return $http.post(_uri("api/exam/".concat(name)), answers, {
      asJson: true
    });
  };

  service.feedbackPost = function (data) {
    return $http.post(_uri('api/feedback'), data, {
      asJson: true
    });
  };

  return service;
}]);
angular.module('app.services').factory('$dict', function () {
  var service = {};

  service.questions = function () {
    return [{
      text: 'Which of the following is not considered a Critical Dose Drug by Health Canada?',
      answers: [{
        text: 'Cyclosporine'
      }, {
        text: 'Mycophenolate Mofetil',
        isCorrect: true
      }, {
        text: 'Sirolimus'
      }, {
        text: 'Tacrolimus'
      }]
    }, {
      text: 'Which of the following statements is <u>true</u> regarding Critical Dose Drugs?',
      answers: [{
        text: 'Critical dose drugs have a relatively large therapeutic index'
      }, {
        text: 'Critical dose drugs are drugs for which comparatively large differences in dose or concentration can lead to therapeutic failures'
      }, {
        text: 'Critical dose drugs are drugs for which comparatively small differences in dose or concentration can lead to potentially serious adverse reactions or therapeutic failures',
        isCorrect: true
      }, {
        text: 'Critical dose drugs are biologic medical products that are almost an identical copy of the original innovator product'
      }]
    }, {
      text: 'Which of the following statements from the Canadian Society of Transplantation recommendations on generic immunosuppression in solid organ transplant recipients is <u>false</u>?',
      answers: [{
        text: 'Generic immunosuppression use should be approached with caution'
      }, {
        text: 'Close monitoring is essential when initiating therapy and with any change in critical dose drug product'
      }, {
        text: 'Patient education regarding generic medications and generic substitution is essential'
      }, {
        text: 'Generic immunosuppressive formulations in pediatric solid organ transplant recipients is recommended',
        isCorrect: true
      }]
    }, {
      text: 'Which of the following statements is <u>true</u> regarding bioequivalence or alternative formulations (generics)?',
      answers: [{
        text: 'Bioequivalence needs to be shown from a single generic to the innovator formulation, but not from one generic to another generic',
        isCorrect: true
      }, {
        text: 'Bioequivalence needs to be shown from a single generic to the innovator formulation, and also from one generic to another generic'
      }, {
        text: 'For critical dose drugs, the ratio of area under the curve (AUC) for generic vs. innovator formulations should be within the limits of 80-125% in order to be deemed bioequivalent'
      }, {
        text: 'Bioequivalence is based on the rate and extent of absorption of a drug into the systemic circulation'
      }]
    }, {
      text: 'Which of the following statements is <u>false</u> regarding intrapatient variability (IPV) in pharmacokinetics?',
      answers: [{
        text: 'Intrapatient variability refers to variability within an individual over time'
      }, {
        text: 'Intrapatient variability refers to variability from one individual to another individual',
        isCorrect: true
      }, {
        text: 'High intrapatient variability with critical dose immunosuppressant drugs may put a patient at risk of over- or under-immunosuppression'
      }, {
        text: 'High intrapatient variability in immunosuppressant drug exposure is associated with poorer outcomes in solid organ transplant recipients'
      }]
    }, {
      text: 'Which of the following is <b>not considered a key factor</b> in specific target concentrations for therapeutic drug monitoring for narrow therapeutic index drugs?',
      answers: [{
        text: 'Transplanted organ'
      }, {
        text: 'Risk of rejection (immunologic risk)'
      }, {
        text: 'Gender',
        isCorrect: true
      }, {
        text: 'Time post-transplant'
      }]
    }, {
      text: 'Which of the following statements regarding prescribability and switchability of alternative formulations is <u>false</u>?',
      answers: [{
        text: 'Prescribability refers to the confidence in safety/efficacy of bioequivalence when prescribing a drug to a naïve patient'
      }, {
        text: 'Switchability refers to the appropriate transfer of a patient from one drug product formulation to another and may require dose adjustment'
      }, {
        text: 'Switchability refers to the confidence in safety/efficacy of bioequivalence when prescribing a drug to a naïve patient',
        isCorrect: true
      }, {
        text: 'Switchability is not currently part of Health Canada requirements for generic interchangeability'
      }]
    }];
  };

  return service;
});
angular.module('app.services').factory('$form', function () {
  var service = {};

  service.submit = function ($scope, form, callback) {
    if (form.$valid !== true) {
      angular.forEach(form, function (value, key) {
        if (_typeof(value) === 'object' && value.hasOwnProperty('$modelValue')) value.$setDirty();
      });
    }

    if (service.isReady($scope, form) === false) return;
    $scope.status = null;
    $scope.error = null;
    callback(form);
  };

  service.isReady = function ($scope, form) {
    if ($scope.isBusy === true || form.$valid !== true) return false;
    $scope.isBusy = true;
    return true;
  };

  return service;
});
angular.module('app.services').factory('$utils', function () {
  var service = {};

  service.query = function (query) {
    var json = {};

    try {
      if (typeof query === 'undefined') query = document.location.search;
      var split = query.replace(/(^\?)/, '').split('&');

      for (var i = 0; i < split.length; ++i) {
        var item = split[i];
        var index = item.indexOf('=');
        if (index === -1) continue;
        var key = item.substring(0, index);
        var value = item.substr(index + 1).trim();
        json[key.toLowerCase()] = decodeURIComponent(value);
      }
    } catch (e) {}

    return json;
  };

  return service;
});
angular.module('app.controllers').controller('accountEmailConfirmationController', ['$scope', '$auth', '$state', function ($scope, $auth, $state) {
  var params = $state.params;
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;

  if (!params.emailConfirmationToken || !params.accountId) {
    $scope.status = 404;
    $scope.description = 'Email confirmation link is incorrect!';
    return;
  }

  $auth.emailConfirmation(params.emailConfirmationToken, params.accountId).then(function (response) {
    $scope.status = 200;
    $scope.description = 'Your account has been activated.';
  }, function (error) {
    $scope.status = error.status;
    $scope.description = error.data.error_description;
  }).finally(function () {
    $scope.isBusy = false;
  });
}]);
angular.module('app.controllers').controller('accountController', ['$scope', '$state', '$api', '$auth', function ($scope, $state, $api, $auth) {
  //return $state.go('exam/feedback');
  if ($auth.isInRoles(['admin'])) return $state.go('admin/report');
  $scope.model = {};
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = true;
  $scope.view = null;
  $api.examResults().then(function (response) {
    $scope.status = 200;
    $scope.model.examResults = response;
    var isAnyPreTest = $scope.model.examResults.filter(function (item) {
      return item.examName === 'pre-test';
    }).length > 0;
    var isAnyPostTest = $scope.model.examResults.filter(function (item) {
      return item.examName === 'post-test';
    }).length > 0;
    var isAnySuccessPostTest = $scope.model.examResults.filter(function (item) {
      return item.examName === 'post-test' && item.isSuccess;
    }).length > 0;
    /*--------------------------------------------------------------------*/
    //isAnySuccessPostTest = true

    isAnyPreTest = false;
    isAnySuccessPostTest = false;
    /*--------------------------------------------------------------------*/

    if (!isAnyPreTest && !isAnyPostTest) return $scope.view = 'question';
    if (isAnySuccessPostTest) return $scope.view = 'download-certificate';
    return $state.go('exam/post-test');
  }, function (error) {
    $scope.status = error.status;
    $scope.description = error.data.error_description;
  }).finally(function () {
    $scope.isBusy = false;
  });
}]);
angular.module('app.controllers').controller('accountRecoverPasswordController', ['$scope', '$form', '$auth', function ($scope, $form, $auth) {
  $scope.model = {};
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;

  $scope.submit = function (form) {
    $form.submit($scope, form, function () {
      return $auth.recoverPassword({
        email: $scope.model.email
      }).then(function (response) {
        $scope.status = 200;
        $scope.description = response.description;
      }, function (error) {
        $scope.status = error.status;
        $scope.description = error.data.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('accountResetPasswordController', ['$scope', '$state', '$form', '$auth', function ($scope, $state, $form, $auth) {
  $scope.model = {};
  var params = $state.params;
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;

  if (!params.resetPasswordToken || !params.accountId) {
    $scope.status = 404;
    $scope.description = 'Reset password link is incorrect!';
    return;
  }

  $scope.submit = function (form) {
    $form.submit($scope, form, function () {
      return $auth.resetPassword(params.resetPasswordToken, params.accountId, $scope.model.password).then(function (response) {
        $scope.status = 200;
        $scope.description = response.description;
      }, function (error) {
        $scope.status = error.status;
        $scope.description = error.data.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('accountSignInController', ['$scope', '$state', '$form', '$auth', function ($scope, $state, $form, $auth) {
  $scope.model = {};
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;

  $scope.submit = function (form) {
    $form.submit($scope, form, function () {
      return $auth.signIn($scope.model.email, $scope.model.password).then(function () {
        if ($state.params.returnUrl) $state.go($state.params.returnUrl);else $state.go('account');
      }, function (error) {
        $scope.status = error.status;
        $scope.description = error.data.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('accountSignUpController', ['$scope', '$form', '$auth', function ($scope, $form, $auth) {
  $scope.model = {//userName: 'MegaZver',
    //password: 'anatole64',
    //firstName: 'Oleksandr',
    //lastName: 'Zvieriev',
    //email: 'ozvieriev@gmail.com',
    //ocupation: 'Web Developer',
    //pharmacistLicense: '87538947593',
    //city: 'Montreal',
    //isOptin: true
  };
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;

  $scope.submit = function (form) {
    $form.submit($scope, form, function () {
      return $auth.signUp(angular.copy($scope.model)).then(function (response) {
        $scope.status = 200;
        $scope.status = 200;
        $scope.description = response.description;
      }, function (error) {
        $scope.status = error.status;
        $scope.description = error.data.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('adminReportController', ['$scope', '$auth', '$state', function ($scope, $auth, $state) {
  $scope.model = {};

  $scope.downloadExamReport = function () {};

  $scope.downloadEvaluationReport = function () {
    window.open("/api/feedback/report/?".concat($.param($scope.model)), '_blank');
  };
}]);
angular.module('app.controllers').controller('examFeedbackController', ['$scope', '$sce', '$form', '$api', function ($scope, $sce, $form, $api) {
  $scope.model = {};

  $scope.getRatings = function () {
    return [1, 2, 3, 4, 5];
  };

  $scope.getRatingsYesNo = function () {
    return [{
      text: 'Yes',
      value: true
    }, {
      text: 'No',
      value: false
    }];
  };

  $scope.getProgramRatings = function () {
    return [{
      text: 'Poor',
      value: 1
    }, {
      text: 'Below Average',
      value: 2
    }, {
      text: 'Average',
      value: 3
    }, {
      text: 'Above Average',
      value: 4
    }, {
      text: 'Excellent',
      value: 5
    }];
  };

  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;

  $scope.submit = function (form) {
    $form.submit($scope, form, function () {
      debugger;
      return $api.feedbackPost($scope.model).then(function (response) {
        $scope.status = 200;
        $scope.description = response.description;
      }, function (error) {
        $scope.status = error.status;
        $scope.description = error.data.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('examPostTestController', ['$scope', '$sce', '$form', '$api', function ($scope, $sce, $form, $api) {
  var _exam = 'post-test';
  $scope.model = {};
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;
  $scope.view = 'questioner';
  $scope.isAllSelected = false;
  $api.exam(_exam).then(function (response) {
    $scope.model.questions = viewQuestionBuilder.build(response);
  }).finally(function () {});

  $scope.onSelect = function () {
    if (!$scope.model.questions) return;

    for (var index = 0; index < $scope.model.questions.length; index++) {
      var question = $scope.model.questions[index];
      if (!question.selectedAnswer) return $scope.isAllSelected = false;
    }

    $scope.isAllSelected = true;
  };

  $scope.submit = function (form) {
    $form.submit($scope, form, function () {
      var answers = [];

      for (var index = 0; index < $scope.model.questions.length; index++) {
        var question = $scope.model.questions[index];
        question.selectedAnswer && answers.push(question.selectedAnswer);
      }

      if (!answers.length) return;
      return $api.examPost(_exam, answers).then(function (response) {
        $scope.status = 200;
        $scope.description = response.description;
        $scope.view = 'done';
      }, function (error) {
        $scope.status = error.status;
        $scope.description = error.data.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };

  var viewQuestion = function viewQuestion(json) {
    this.id = json.id;
    this.text = $sce.trustAsHtml(json.text);
    this.answers = viewAnswerBuilder.build(json);
    this.selectedAnswer = null;
  };

  var viewAnswer = function viewAnswer(json) {
    this.id = json.id;
    this.text = $sce.trustAsHtml(json.text);
    this.isCorrect = json.isCorrect;
  };

  var viewQuestionBuilder = function viewQuestionBuilder() {};

  viewQuestionBuilder.build = function (json) {
    var questions = [];

    if (json.questions) {
      for (var index = 0; index < json.questions.length; ++index) {
        var question = json.questions[index];
        questions.push(new viewQuestion(question));
      }
    }

    return questions;
  };

  var viewAnswerBuilder = function viewAnswerBuilder() {};

  viewAnswerBuilder.build = function (json) {
    var answers = [];

    if (json.answers) {
      for (var index = 0; index < json.answers.length; ++index) {
        var answer = json.answers[index];
        answers.push(new viewAnswer(answer));
      }
    }

    return answers;
  };
}]);
angular.module('app.controllers').controller('examPreTestController', ['$scope', '$sce', '$form', '$api', '$dict', '$filter', function ($scope, $sce, $form, $api, $dict, $filter) {
  var viewQuestion = function viewQuestion(json) {
    var text = json.text;
    text && (text = $filter('translate')(text));
    this.text = $sce.trustAsHtml(text);
    this.answers = viewAnswerBuilder.build(json);
    this.selectedAnswer = null;
  };

  var viewAnswer = function viewAnswer(json) {
    var text = json.text;
    text && (text = $filter('translate')(text));
    this.text = $sce.trustAsHtml(text);
    this.isCorrect = json.isCorrect;
  };

  var viewQuestionBuilder = function viewQuestionBuilder() {};

  viewQuestionBuilder.build = function (questions) {
    var result = [];

    if (questions) {
      for (var index = 0; index < questions.length; ++index) {
        var question = questions[index];
        result.push(new viewQuestion(question));
      }
    }

    return result;
  };

  var viewAnswerBuilder = function viewAnswerBuilder() {};

  viewAnswerBuilder.build = function (json) {
    var answers = [];

    if (json.answers) {
      for (var index = 0; index < json.answers.length; ++index) {
        var answer = json.answers[index];
        answers.push(new viewAnswer(answer));
      }
    }

    return answers;
  };

  var _exam = 'pre-test';
  $scope.model = {
    questions: viewQuestionBuilder.build($dict.questions())
  };
  $scope.status = null;
  $scope.description = null;
  $scope.isBusy = false;
  $scope.$sce = $sce;
  $scope.view = 'questioner';
  $scope.isAllSelected = false; //$api.exam(_exam)
  //    .then((response) => {
  //        $scope.model.questions = viewQuestionBuilder.build(response);
  //    })
  //    .finally(() => { });

  $scope.onSelect = function () {
    //if (!$scope.model.questions)
    //    return;
    //for (var index = 0; index < $scope.model.questions.length; index++) {
    //    var question = $scope.model.questions[index];
    //    if (!question.selectedAnswer)
    //        return ($scope.isAllSelected = false);
    //}
    $scope.isAllSelected = true;
  };

  $scope.submit = function (form) {
    $form.submit($scope, form, function () {
      var answers = [];

      for (var index = 0; index < $scope.model.questions.length; index++) {
        var question = $scope.model.questions[index];
        question.selectedAnswer && answers.push(question.selectedAnswer);
      }

      if (!answers.length) return;
      return $api.examPost(_exam, answers).then(function (response) {
        $scope.status = 200;
        $scope.description = response.description;
        $scope.view = 'done';
      }, function (error) {
        $scope.status = error.status;
        $scope.description = error.data.error_description;
      }).finally(function () {
        $scope.isBusy = false;
      });
    });
  };
}]);
angular.module('app.controllers').controller('partialHeaderController', ['$scope', '$state', '$auth', '$translate', function ($scope, $state, $auth, $translate) {
  $scope.$auth = $auth;

  $scope.changeLanguage = function (lang) {
    $translate.use(lang).then(function () {
      var url = $state.current.url.replace(/^\//g, '');
      var params = angular.copy($state.params);
      params.locale = lang;
      $state.go(url, params);
    });
  };

  $scope.logout = function () {
    $auth.logout();
  };
}]);